\chapter{Diseño e Implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\large,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,					% the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}%
}

En este capítulo se presentan la arquitectura multicore del \textit{firmware}, los mecanismos de comunicación entre procesadores y el detalle del diseño de los módulos desarrollados junto con sus interfaces.  Finalmente, se incluye una sección de trazabilidad de requerimientos con las funciones implementadas.

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Arquitectura multicore}
\label{sec:arquitectura}

El \textit{firmware} está desarrollado sobre la base de dos proyectos vinculados dentro IDE MCUXpresso, uno para cada \textit{core} del microcontrolador. Para el IDE, debe haber un proyecto ``maestro'' que controle la ejecución del código (o al menos la secuencia de \textit{startup}) corriendo en el otro \textit{core}, considerado ``esclavo''.  

El proyecto maestro contiene un link al proyecto esclavo que produce que la imagen binaria del esclavo sea incluida en la imagen  binaria del maestro, cuando el proyecto maestro es compilado \citep{nxp:mcuxpresso}. De esta manera, cuando el proyecto maestro es grabado en la flash del microcontrolador, ambos proyectos son descargados a la memoria del microcontrolador.

El proyecto maestro debe ser el que se ejecuta sobre el procesador Cortex-M4 ya que el procesador Cortex-M0 permanece en estado de \textit{reset} hasta que el otro \textit{core} lo libera de este estado escribiendo un 0 en el bit M0SUB\_RST del registro RESET\_CTRL1, como se indica en el manual del microcontrolador \citep{nxp:lpc4337}.

Cuando se energiza el microcontrolador o se produce un \textit{reset}, el \textit{core} maestro inicia su secuencia de \textit{startup} y es responsable de iniciar, a su vez, la secuencia de \textit{startup} del \textit{core} esclavo.  

En las tablas \ref{tab:memoriaM4} y \ref{tab:memoriaM0} se muestra la asignación de bloques de memoria para los procesadores Cortex-M4 y Cortex-M0, respectivamente.  Puede verse que el código de cada procesador se ubica en un bloque de memoria flash independiente, los bancos A y B de 512 kB cada uno.  

Por otra parte, para evitar cualquier tipo de solapamiento en el uso de la RAM, los proyectos asociados a cada \textit{core} se linkean de forma de utilizar exclusivamente bancos de RAM separados.  En este sentido, el procesador cortex-M4 utiliza el primer bloque de RAM de 32 kB y el procesador cortex-M0 utiliza el segundo bloque de RAM de 40kB.

\begin{table}[ht]
\centering
\caption{Asignación de bloques de memoria para el Cortex-M4}
\begin{tabular}{lllll}
\toprule
\textbf{Tipo de memoria} & \textbf{Nombre} & \textbf{Alias} & \textbf{Ubicación} & \textbf{Tamaño} \\ 
\midrule
Flash                    & MFlashA512      & Flash          & 0x1a000000         & 0x80000         \\
RAM                      & RamLoc32        & RAM            & 0x10000000         & 0x8000          \\ 
\bottomrule
\end{tabular}
\label{tab:memoriaM4}
\end{table}

\begin{table}[ht]
\centering
\caption{Asignación de bloques de memoria para el Cortex-M0}
\begin{tabular}{lllll}
\toprule
\textbf{Tipo de memoria} & \textbf{Nombre} & \textbf{Alias} & \textbf{Ubicación} & \textbf{Tamaño} \\ 
\midrule
Flash                    & MFlashB512      & Flash2          & 0x1b000000         & 0x80000         \\
RAM                      & RamLoc40        & RAM2            & 0x10080000         & 0xa000          \\ 
\bottomrule
\end{tabular}
\label{tab:memoriaM0}
\end{table}

Adicionalmente, se define una zona de memoria compartida, visible por ambos procesadores para el intercambio de información. Los mecanismos de comunicación inter-procesadores (IPC, del inglés \textit{Inter Processor Communication}) se describen en la sección \ref{subsec:IPC}. 

\begin{verbatim}
/* Shared memory used by IPC */
#define SHARED_MEM_IPC   0x10088000	 
\end{verbatim}

\subsection{Inter Processor Communications}
\label{subsec:IPC}

Para comunicar ambos procesadores se utiliza una biblioteca provista por el fabricante del microcontrolador NXP, documentada en la nota de aplicación ``AN1117: Inter Processor Communications for LPC43xx'' \citep{nxp:an1117}. En este documento se explican mecanismos posibles para que los dos procesadores intercambien información basados en interrupciones, en colas de mensajes y en ``casillas de correo''.  Este último método queda excluido de esta memoria por no haber sido utilizado en el desarrollo.

\subsubsection{Interrupciones cruzadas}
\label{subsubsec:interrupcion}

El mecanismo de interrupciones cruzadas es el más simple de los 3 métodos provistos.  Permite que un \textit{core} active una interrupción en el otro \textit{core} para enviar notificaciones cuya interpretación depende y es exclusiva de la aplicación.  El diseñador puede definir una función de \textit{callback} que es ejecutada en el contexto de la rutina de servicio de la interrupción.  

Para enviar señales al \textit{core} ``remoto'', el \textit{core} ``local'' utiliza una instrucción dedicada SEV (\textit{send event}) provista por la arquitectura Cortex.

Asimismo, dentro de la rutina de interrupción se habilita un \textit{flag} para indicar que se ha recibido una notificación IPC.  Esta variable \textit{flag} puede ser usada por las aplicaciones corriendo sobre el \textit{core} que recibe la notificación para chequear el estado de las comunicaciones. 

La limpieza del \textit{flag} se hace dentro de una sección crítica donde se deshabilitan temporalmente las interrupciones. En el Cortex-M4 se enmascaran las interrupciones con mayor prioridad y en el Cortex-M0 se deshabilitan directamente, ya que este procesador no dispone del mecanismo de enmascaramiento.

El código para generar las interrupciones cruzadas utiliza dos macros. Primero \_\_DSB() (\textit{Data Syncronization Barrier}) para terminar todas las transacciones de memoria pendientes y luego \_\_SEV() (\textit{Send Event}) para generar el envío de una señal de interrupción al otro procesador como puede verse en el algoritmo \ref{lst:ipc_send_signal}.
%, como puede apreciarse en \ref{cod:interrupt}
%\begin{verbatim}
%/*
% * Initiate interrupt on other processor
% * Upon calling this function generates and interrupt 
% * on the other core. Ex. if called from M0 core it 
% * generates interrupt on M4 core and vice versa.
% */
%static void ipc_send_signal(void)
%{
%  	__DSB();
%  	__SEV();
%}
%\end{verbatim}\label{cod:interrupt}  

\begin{lstlisting}[caption={Función ipc\_send\_signal que permite generar una interrupción en el otro procesador.},label={lst:ipc_send_signal}]
/*
 * Initiate interrupt on other processor
 * Upon calling this function generates and interrupt 
 * on the other core. Ex. if called from M0 core it 
 * generates interrupt on M4 core and vice versa.
 */
static void ipc_send_signal(void)
{
  	__DSB();
  	__SEV();
}
\end{lstlisting}

\subsubsection{Colas de mensajes}
\label{subsubsec:colas}

En el método de colas de mensajes, se deben definir dos áreas de memoria compartida, que se utilizan para almacenar los mensajes que cada procesador envía al otro. Una cola (búfer de comandos del \textit{host}) está dedicado a los comandos enviados del procesador maestro al esclavo, y una cola (búfer de mensajes del \textit{host}) se dedica a los mensajes que el procesador esclavo envía en respuesta al procesador maestro. La figura \ref{fig:IPC} muestra esquemáticamente esta configuración.

\vspace{10px}

\begin{figure}[ht]
	\centering
	\includegraphics[width=.8\textwidth]{./Figures/IPC.png}
	\caption[Esquema de comunicación entre procesadores]{Esquema de comunicación entre procesadores basado en colas de mensajes\protect\footnotemark.}
	\label{fig:IPC}
\end{figure}

\vspace{10px}
\vfill
\footnotetext{Imagen tomada del manual de usuario del microcontrolador LPC4337 \citep{nxp:lpc4337}}

En el esquema propuesto, sólamente el procesador maestro puede escribir en el búfer de comandos y recibe los mensaje del esclavo leyendo el búfer de mensajes.  De manera análoga, únicamente el esclavo puede escribir en el búfer de mensajes y recibe comandos leyendo el búfer de comandos.

Cuando un procesador escribe un nuevo mensaje en una cola, debe notificar al otro procesador de que hay nueva información para procesar. Para tal fin, se utiliza el mecanismo de interrupción descrito en el apartado Interrupciones cruzadas, dentro de la subsección \ref{subsubsec:interrupcion}.  Luego de esto, el procesador que recibe el mensaje invoca a un despachador de eventos que busca en un vector de manejadores de eventos el que haya sido registrado para tal fin. En el algoritmo \ref{lst:ipc_dispatcher} se pude apreciar la función provista por la bilbioteca IPC para despachar eventos.

\vspace{10px}

\begin{lstlisting}[caption={Función despachadora de eventos de la biblioteca IPC.},label={lst:ipc_dispatcher}]
/* This task will receive the message from the other 
 * core and will invoke the appropriate callback with
 * the message
 */
static void ipcex_dispatch_task(void *unused)
{
  int ret;
  ipcex_msg_t msg;
  	do {
    	ret = IPC_popMsgTout(&msg, -SYS_OS_ID);
    	if((ret != QUEUE_VALID) || 
                      (msg.id.pid >= IPCEX_MAX_PID)){
      	continue;
    	}
    	if (ipcex_callback_lookup[msg.id.pid]) {
      	ipcex_callback_lookup[msg.id.pid](&msg);
    	}
  	} while (SYS_OS_ID);
}
\end{lstlisting}
\vspace{5px}
SYS\_OS\_ID es una macro que se utiliza para identificar el tipo de Sistema Operativo incluido en la aplicación.  En el caso particular de este trabajo, SYS\_OS\_ID es igual a 0 y esto significa que no hay Sistema Operativo.  Se debe notar que SYS\_OS\_ID = 0 implica que el despachador de eventos se ejecuta una única vez por mensaje recibido.

La función despachadora de eventos descrita en el algoritmo \ref{lst:ipc_dispatcher} fue modificada para adaptarla a las necesitadas del proyecto.  En la sección \ref{sec:control} se documenta cómo se implementó esta función dentro del módulo de control de la estación de monitoreo de ruido acústico.

Para el intercambio de mensajes en el sistema, se define un nuevo tipo de dato \texttt{ipcex\_msg\_t}.  Se trata de una estructura que contiene información que identifica al CPU y al proceso destinararios del mensaje, definidos dentro de otra estructura anidada, junto con dos campos para datos como se observa en el algoritmo \ref{lst:ipcex_msg_t}. 

\begin{lstlisting}[caption={Definición de un nuevo tipo de dato ipcex\_msg\_t para intercambio de mensajes.},label={lst:ipcex_msg_t}]
typedef struct __ipcex_msg {
  struct {
    uint16_t cpu;
    uint16_t pid;
  } id;

  uint32_t data0;
  uint32_t data1;
} ipcex_msg_t;
\end{lstlisting}

El tipo de datos \texttt{ipcex\_msg\_t}, tal como viene definido en la biblioteca IPC fue modificado como se documenta en la sección \ref{sec:control}.

\section{Diseño de módulos y definición de interfaces}
\label{sec:modulos}

El optó por un diseño fuertemente modularizado en archivos, junto a un modelo de capas jerárquicas para organizar el código en distintos niveles de abstracción.  

En la figura \ref{fig:capas} se pueden observar, agrupados por color, las capas utilizadas en este trabajo.  En color amarillo, el paquete de drivers provistos por el fabricante del silicio; en color naranja la capa de bibiotecas; la capa de abstracción de \textit{hardware} (HAL, por sus siglas en inglés) en color verde; y finalmente, en color celeste, la capa de aplicación con los cuatro módulos implementados.   

%\vspace{10px}

\begin{figure}[ht]
	\centering
	\includegraphics[width=.5\textwidth]{./Figures/capas.pdf}
	\caption[Estructura de capas para el \textit{firmware}.]{Estructura de capas para el \textit{firmware}. En orden creciente de nivel de abstracción: \textit{core support package} (amarillo), bibliotecas (naranja), sAPI (verde) y la capa de aplicación (celeste) con los 4 módulos implementados.}
	\label{fig:capas}
\end{figure}

\vspace{10px}

Para los módulos en la capa de aplicación, se confeccionó una matriz de trazabilidad de los requerimientos referidos al firmware, detallados en la sección \ref{sec:requerimientos}. 

La tabla \ref{tab:trazabilidad} permite saber en qué módulo del firmware serán implementados los requerimientos funcionales del proyecto.  Asimismo, permite controlar que todo este subconjunto de requerimientos sea implementado y que no haya superposición entre la funcionalidad de cada módulo.

\vspace{5px}

\begin{table}[ht]
\caption[Matriz de trazabilidad de requerimientos funcionales]{Matriz de trazabilidad de requerimientos funcionales con los módulos de \textit{firmware}}
\label{tab:trazabilidad}
\begin{tabular}{lcccc}
\toprule
\textbf{Requerimiento} & \textbf{Control} & \textbf{sdCard} & \textbf{Adquisición} & \textbf{HMI} \\ \midrule
2.1 Adquirir temperatura                   &                  &                 & X                    &              \\ %\hline
2.2 Adquirir velocidad de viento           &                  &                 & X                    &              \\ %\hline
2.3 Almacenar datos                        &                  & X               &                      &              \\ %\hline
2.4 Perfiles de consumo                    & X                &                 &                      &              \\ %\hline
2.5 Interfaz                               &                  &                 &                      & X            \\ \bottomrule
\end{tabular}
\end{table}

Se definió un nuevo tipo de dato, \texttt{module\_t} que contiene campos de control para los módulos. Se observa su la definición el el algoritmo \ref{lst:module_t}.

El primer campo de \texttt{module\_t} indica en qué procesador debe ejecutarse el módulo. Sigue un campo para identificar al módulo y un puntero a la función manejadora de eventos que será invocada cada vez que haya un mensaje para este módulo. Para temporizar en forma periódica la ejecución del módulo se utiliza el campo \texttt{period} y, finalmente, se incluye un campo para el estado del módulo que puede tomar uno de los siguientes valores: DISABLE, READY o PROCESSING.

\vspace{10px}

\begin{lstlisting}[caption={Definición de un nuevo tipo de dato module\_t.},label={lst:module_t}]
typedef struct {
   CPUID_T coreID;
   moduleID_t moduleID;
   funcPtr_t eventHandler;
   tick_t period;
   moduleStatus_t status;
} module_t;
\end{lstlisting}

\vspace{10px}

Toda la interacción con los módulos se realiza a través de los respectivos manejadores de eventos y una cola de mensajes como la descrita en la subsección \ref{subsubsec:colas}. Para el intercambio de mensajes entre módulos que se encuentren en ejecución en un mismo procesador, se levantaron las restricciones de escritura sobre la propia cola de mensajes que se originalmente pesaban sobre cada procesador.

A continuación se listan los prototipos de los manejadores de eventos definidos:

\vspace{10px}

\begin{itemize}
  \item \texttt{void onewire\_handler(const ipcex\_msg\_t * msg );} 
  \item \texttt{void hmi\_handler(const ipcex\_msg\_t * msg );} 
  \item \texttt{void sdcard\_handler(const ipcex\_msg\_t * msg );} 
  \item \texttt{void control\_handler(const ipcex\_msg\_t * msg );} 
\end{itemize}

\vspace{10px}

Puede notarse que todos los manejadores reciben un mismo tipo de parámetro, un puntero constante a un mensaje de tipo \texttt{ipcex\_msg\_t}.  Cada módulo es responsable de interpretar los dos campos enteros sin signo de 32 bits de datos que contiene el mensaje.  Normalmente el campo \texttt{data0} define un comando y \texttt{data1} se utiliza opcionalmente para el envío de parámetros.

Para todos los módulos se utilizó un modelo de \textit{firmware} basado en máquinas de estados finitos (MEF) jerárquicas, donde una MEF principal controla la lógica de funcionamiento con el mayor nivel de abstracción. Los diferentes estados, a su vez, pueden o no estar modelados con MEFs dependiendo de la conveniencia de esto último.

Se definió una arquitectura de máquia de estados finitos principal lo más genérica posible de forma que pueda ser compartida por los distintos módulos.  En este sentido, todos los módulos poseen un estado \texttt{DISABLE}, \texttt{INIT}, \texttt{IDLE}, \texttt{CONFIG} y \texttt{CHECK}. La funcionalidad que implemente cada uno de estos estados será propia del módulo donde estén definidos. 

Todos los módulos inician en estado \texttt{DISABLE}. Adicionalmente, la máquina de estados finitos podrá tener otros estados que sean específicos para lograr sus propósitos funcionales.

En la figura \ref{fig:mef_generica} se muestra un diagrama de la máquina de estados finitos genérica, diseñada para ser usada como base en cada uno de los módulos que componen el sistema.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/MEF_generica.pdf}
	\caption[Diseño de MEF genérica para los módulos]{Diseño de máquina de estados finitos genérica para el control de la lógica de los módulos}
	\label{fig:mef_generica}
\end{figure}

\section{Módulo de almacenamiento}
\label{sec:almacenamiento}

El propósito del módulo de almacenamiento es proveer al sistema de una interfaz para operar con un medio de almacenamiento no volátil que permita guardar en forma permanente los datos registrados por el módulo de adquisición y eventualmente un log con información de \textit{debug}.  

\subsection{Medio físico}
\label{subsec:mediofisico}

Se evaluaron distintas opciones de medios físicos.  En la tabla \ref{tab:medios} se recopilan las alternativas analizadas y se especifica un orden de magnitud para la capacidad de almacenamiento posible, el tipo de interfaz con el microcontrolador y el protocolo que debe implementarse en el \textit{firmware} para su utilización.

\vspace{10px}

\begin{table}[ht]
\centering
\caption{Alternativas de medios físicos evaluados.}
\label{tab:medios}
\begin{tabular}{lrcc}
\toprule
\multicolumn{1}{c}{\textbf{Medio físico}} & \multicolumn{1}{c}{\textbf{Capacidad}} & \textbf{Interfaz} & \textbf{Protocolo} \\ \midrule
USB Mass Storage Device                   & $\sim$10 Gb                            & USB 2.0           & USB                \\
Tarjeta de memoria microSD                & $\sim$10 Gb                            & Micro SD          & SSP                \\
Disco de estado sólido (SSD)              & $\sim$100 Gb                           & SATA III          & SATA               \\
Disco duro mecánico (HHD)                 & $\sim$1000 Gb                          & SATA III          & SATA               \\ \bottomrule
\end{tabular}
\end{table}

\vspace{10px}

Teniendo en cuenta criterios de costos y simplicidad de interacción con la CIAA-NXP, se decidió utilizar un lector de tarjetas microSD con comunicación sobre un puerto \textit{Synchronous Serial Port} (SSP).  Este protocolo es compatible con el protocolo SPI y utiliza un bus de 4 cables con las señales SCK, SSEL, MISO y MOSI.  Asimismo, el soporte seleccionado minimiza el consumo de energía comparado con las otras alternativas, lo cual lo hace deseable para la aplicación.  

El lector de tarjetas utilizado se presenta en la figura \ref{fig:lector_sdCard}, donde puede verse esquemáticamente el diagrama de conexionado eléctrico entre la CIAA-NXP y el lector (figura \ref{fig:lector_conexionado}) y una vista superior del módulo de hardware (figura \ref{fig:lector_hardware}). Cabe notar que al haber un único dispositivo ``escalvo'' en el bus SSP, la señal de \textit{chip select} (CS) se conecta con GND, lo que implica que el dispositivo está permanente seleccionado.

\vspace{20px}

\begin{figure}[h]
	\centering
	\begin{subfigure}{.4\textwidth}
		\centering
		\begin{tabular}{rll}
			\textbf{CIAA-NXP }&	& \textbf{Lector de tarjetas}\\
			+3.3V     & --\textgreater{} & +3.3V   \\
			GND       & --\textgreater{} & CS  \\
			SPI\_MOSI & --\textgreater{} & MOSI  \\
			SPI\_SCK  & --\textgreater{} & SCK \\
			SPI\_MISO & --\textgreater{} & MISO  \\
			GND       & --\textgreater{} & GND  \\
		\end{tabular}
		\caption{ }
  		\label{fig:lector_conexionado}
	\end{subfigure}%
	\begin{subfigure}{.6\textwidth}
	\hspace{15px}
		\centering
		\includegraphics[height=3.3cm]{./Figures/sdCardReader.jpg}
		\caption{ }
		\label{fig:lector_hardware}
	\end{subfigure}
	\caption{(A) Diagrama de conexionado eléctrico y (B) Lector de tarjetas SD utilizado.}
	\label{fig:lector_sdCard}
\end{figure}

\vspace{10px}

Para la utilización del lector de tarjetas se hizo uso de la biblioteca FatFs, desarrollada por chaN \citep{fatFS}. FatFs es un módulo de sistema de archivos FAT/exFAT genérico para sistemas embebidos limitados en recursos. En la figura \ref{fig:chan} se esquematizan las interfaces de la biblioteca en una aplicación típica. 

\begin{figure}[htpb]
	\centering
	\includegraphics[width=.5\textwidth]{./Figures/chan.png}
	\caption[Diagrama de capas de fatFs]{Diagrama de capas con la ubicación de la biblioteca fatFs en el sistema y sus interfaces\protect\footnotemark.}
	\label{fig:chan}
\end{figure}

\footnotetext{Imagen tomada de \url{http://elm-chan.org/fsw/ff/doc/appnote.html}.}

El código está escrito en ANSI C y es \textit{software} libre bajo licencia estilo BSD \citep{BSD}.

\subsection{Máquina de Estados Finitos}
\label{subsec:MEFsdcard}

Se presenta el diagrama de estado de la MEF principal del módulo en la figura \ref{fig:mef_sdcard}, donde puede apreciase el punto de entrada con un circulo negro, los estado que puede tomar la máquina y las señales que provocan los cambios de estado. Se omiten del gráfico las salidas del sistema por simplicidad. 

Debe notarse que al energizarse el sistema o luego de un \textit{reset}, el módulo se encuentra deshabilitado, con la MEF en el estado \texttt{DISABLE}, del cual sólo puede salir si se recibe una señal de inicialización.  

Una vez inicializado, el módulo se encontrará la mayor parte del tiempo en el estado \texttt{IDLE} a la espera de un comando válido.  

Cuando el módulo esté realizando alguna operación de lectura, escritura o actualización sobre la tarjeta SD, el estado del módulo tendrá el valor \texttt{PROCESSING} para indicarle al módulo de control que debe tener acceso a tiempo de CPU para poder completar las operaciones pendientes.  

Todas las operación del módulo desde que es inicializado terminan incondicionalmente en el estado \texttt{IDLE}, en donde el valor de la variable que registra el estado del módulo cambia de \texttt{PROCESSING} a \texttt{READY}.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/MEF_sdCard_2.pdf}
	\caption[MEF principal del módulo de almacenamiento sdCard]{Máquina de estados finitos principal del módulo de almacenamiento.}
	\label{fig:mef_sdcard}
\end{figure}

%  Se indican las señales que puede recibir junto con las acciones más relevantes de cada estado. principal del módulo de almacenamiento

En la tabla \ref{tab:estadosAlmacenamiento} se describen los posibles estados de la MEF junto con las señales para alcanzarlos. Asimismo se explicitan las acciones y actividades más destacables que se realizan en cada uno de ellos.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[htpb]
\centering
\caption[Descripción de los estados de la MEF principal del módulo de almacenamiento.]{Descripción de los estados de la MEF principal del módulo de almacenamiento.}
\label{tab:estadosAlmacenamiento}
\resizebox{\textwidth}{!}{%
\begin{tabular}{lll}
\toprule
\multicolumn{1}{c}{\textbf{Estado}} & \multicolumn{1}{c}{\textbf{Señal para cambio}} & \multicolumn{1}{c}{\textbf{Acciones y actividades}} \\ \midrule
DISABLE & Reset o sig\_disable & \begin{tabular}[c]{@{}l@{}}Desinicializar el controlador SPI.\\ Desinicializar la bilioteca fatFS.\\ Desinicializar el módulo de almacenamiento.\\ Cambiar el estado del módulo de READY a DISABLE.\end{tabular} \\
 &  &  \\
INIT & sig\_init & \begin{tabular}[c]{@{}l@{}}Inicializar el controlador SPI.\\ Inicializar la bilioteca fatFS.\\ Inicializar el módulo de almacenamiento.\\ Cambiar el estado del módulo de DISABLE a READY.\end{tabular} \\
 &  &  \\
IDLE & transición incondicional & Cambiar estado del módulo de PROCESSING a READY. \\
 &  &  \\
CONFIG & sig\_config & Realizar cambios de configuración al módulo. \\
 &  &  \\
CHECK & sig\_check & Realizar autochequeo e informar al módulo de control \\
 &  &  \\
UPDATE & sig\_timeout & Ejecutar tarea periódica de actualización de la tarjeta SD. \\
 &  &  \\
WRITE & sig\_write & Obtener timestamp y escribir datos en la tarjeta SD. \\
 &  &  \\
READ & sig\_read & Leer datos en la tarjeta SD \\ \bottomrule
\end{tabular}%
}
\end{table}


\clearpage
\section{Módulo de adquisición}
\label{sec:adquisicion}

El propósito del módulo de adquisición es proveer al sistema de una interfaz para operar los distintos sensores que puedan conectarse a la estación.  Originalmente, se contempló el uso de uno o varios termómetros y un anemómetro para medir temperatura del agua y velocidad del viento en superficie, respectivamente. Adicionalmente, se contempla incorporar hidrofónos para registrar el nivel de ruido submarino, principal objetivo de la estación de medición.

Se mencionó en la sección \ref{sec:objetivosyalcances}, que los hidrófonos quedaron fuera del alcance del proyecto en esta etapa del desarrollo.  De igual manera, el control del anemómetro quedará fuera de la implementación ya que se optó por priorizar el requerimiento implícito de cumplir con la fecha de entrega.  Se retoma este punto en el capítulo \ref{Chapter5}, en la sección \ref{subsec:metasalcanzadas}, donde se discuten sus implicancias.

Sin pérdida de generalidad, la arquitectura de módulo adoptada puede utilizarse para incorporar los sensores no implementados, en una segunda iteración.

\subsection{Sensor de temperatura}
\label{subsec:1-wire}

%En la presente sección se presenta la implementación del control para el sensor de temperatura. 

Se evaluaron distintas opciones para el sensor de temperatura que estuvieran disponibles en el mercado local.  Se recopila en la tabla \ref{tab:temperatura} la información relevada para los sensores candidatos, donde puede verse fabricante y modelo de cada dispositivo junto con las principales características de interés para la aplicación.

Cabe destacar que la limitante para el rango de temperatura no es el propio sensor sino el plástico que recubre los hilos conductores que lo conectan al microcontrolador, motivo por el cual todas las alternativas evaluadas poseen rangos equivalente.  Se utiliza en la tabla un código sencillo para indicar un orden de magnitud del costo relativo del sensor con \$ para costo bajo, \$\$ para costo medio y \$\$\$ para costo alto.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[htpb]
\centering
\caption{Alternativas de sensor de temperatura evaluadas.}
\label{tab:temperatura}
\resizebox{\textwidth}{!}{%
\begin{tabular}{ccccccc}
\toprule
\textbf{Fabricante} & \textbf{Sensor} & \textbf{Tipo} & \textbf{Precisión (\grados C)} & \textbf{Rango (\grados C)} & \textbf{Interfaz} & \textbf{Costo} \\
\midrule
Maxim Integrated    & DS18B20     & Termómetro digital & $\pm$ 0.5 & -55 a +125   & 1-wire & \$             \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
Genérico            & IM120628010 & Termistor NTC & 1\% & -25 a +125   & 1-wire & \$             \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
Texas Instruments         & LM35  & Integrated Circuit & $\pm$ 0.5 & -55 a +150   & \textit{Analog}         & \$   \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
Altas Scientific    & PT-1000A    & \begin{tabular}[c]{@{}c@{}}RTD \\ (resistance\\ temperature\\ detector)\end{tabular} & $\pm$ (0.15 + 0.002*t)  & -55 a +125   & \textit{Analog}         & \$\$\$         \\
\bottomrule         
\end{tabular}%
}
\end{table}

El sensor elegido es el termómetro digital DS18B20 del fabricante Maxim Integrated \citep{ds18b20}. Los motivos de la elección fueron principalmente la facilidad de uso en un entorno embebido de recursos limitados, la disponibilidad de documentación completa y detallada junto con numerosas notas de aplicación y el bajo costo del dispositivo.

En la figura \ref{fig:ds18b20_bloques} se puede apreciar un diagrama en bloques del sensor, en donde destaca la interfaz de 3 cables con una línea bidireccional de datos (DQ) y dos cables para la alimentación (GND y $V_{DD}$). 

El sensor admite una configuración de alimentación ``parásita'', en la cual se energiza desde la línea de datos DQ, lo que habilita a prescindir de un cable a costa de mayores requerimientos para la temporización de las comunicaciones y la utilización de un transistor a modo de \textit{``strong pull-up''} (conectado el bus de datos directamente a $V_{DD}$).

\begin{figure}[htpb]
	\centering
	\includegraphics[width=.8\textwidth]{./Figures/ds18b20_bloques.png}
	\caption[Diagrama en bloques del sensor de temperatura DS18B20]{Diagrama en bloques del sensor de temperatura\protect\footnotemark.}
	\label{fig:ds18b20_bloques}
\end{figure}

\footnotetext{Imagen tomada de \url{https://www.maximintegrated.com/en/images/qv/2812.png}}

Cada sensor posee un código de identificación único de 64 bits que permite operar con múltiples sensores sobre un mismo bus de tipo 1-wire.  Mediante un algoritmo de descubrimiento se pueden identificar los sensores conectados a un mismo bus y controlarlos independientemente. 

La capacidad para identificar cuántos sensores hay conectados en cada momento y poder interrogarlos individualmente se utilizó para incorporar una funcionalidad de autochequeo, en la cual el microcontrolador es capaz de detectar si un sensor ha dejado de funcionar correctamente.

Otras características destacables son la posibilidad de configurar la resolución entre 9 y 12 bits, el uso de CRC en las comunicaciones y la capacidad para definir umbrales de alarma para los valores de temperatura medidos.

Este sensor se comercializa con distintas longitudes de cable, dentro de un encapsulado metálico sumergible.  Para este trabajo se adquirieron dos sensores sumergibles con 5 metros de cable y 2 metros de cable, respectivamente.   

Los dos sensores operan sobre una misma línea de datos con una resistencia de \textit{pull-up} de 2,2 K$\Omega$, como puede verse en el diagrama de conexionado eléctrico de la figura \ref{fig:ds18b20_conexionado}.  El encapsulado sumergible puede apreciarse en la figura \ref{fig:termometro}.

%\vspace{10px}

\begin{figure}[htpb]
	\centering
	\begin{subfigure}{.6\textwidth}
		\centering
		\includegraphics[height=3.7cm]{./Figures/ds18b20_conexionado.pdf}
		\caption{ Diagrama de conexionado eléctrico}
  		\label{fig:ds18b20_conexionado}
	\end{subfigure}%
	\begin{subfigure}{.4\textwidth}
		\centering
		\includegraphics[height=3.7cm]{./Figures/ds18b20.jpg}
		\caption{ Sensor DS18B20}
		\label{fig:termometro}
	\end{subfigure}
	\caption{}
	\label{fig:ds18b20}
\end{figure}


Para el control de los dispositivos se adaptó una implementación de controlador de bus \textit{1-wire} para microcontroladores de la familia LPC1343, desarrollada en forma de biblioteca por James Harwood \citep{harwood}.  En esta biblioteca se hace uso de las técnicas de programación concurrente descritas en el capitulo \ref{Chapter2}, subsección \ref{subsec:protothreads}.

\subsection{Máquina de Estados Finitos}

En forma análoga a lo presentado en la subsección \ref{subsec:MEFsdcard}, se muestra aquí el diagrama de estado de la MEF principal del módulo en la figura \ref{fig:mef_adquisicion}, donde puede apreciase el punto de entrada con un circulo negro, los estado que puede tomar la máquina y las señales que provocan los cambios de estado. Se omiten del gráfico las salidas del sistema por simplicidad. 

Igualmente, debe notarse que cuando el sistema es energizado o luego de un \textit{reset}, el módulo se encuentra deshabilitado, con la MEF en el estado \texttt{DISABLE}, del cual sólo puede salir si se recibe una señal de inicialización.  

Una vez inicializado, el módulo se encontrará la mayor parte del tiempo en el estado \texttt{IDLE} a la espera de un comando válido.  

Cuando el módulo esté realizando alguna operación de adquisición, configuración o autochequeo sobre los sensores conectados, el estado del módulo tendrá el valor \texttt{PROCESSING} para indicarle al módulo de control que debe tener acceso a tiempo de CPU para poder completar las operaciones pendientes.  

Todas las operación del módulo desde que es inicializado terminan incondicionalmente en el estado \texttt{IDLE}, en donde el valor de la variable que registra el estado cambia de \texttt{PROCESSING} a \texttt{READY}.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/MEF_adquisicion.pdf}
	\caption[MEF principal del módulo de adquisición de temperatura]{Máquina de estados finitos principal del módulo de adquisición de temperatura}
	\label{fig:mef_adquisicion}
\end{figure}

Las principales acciones y actividades de cada estado se describen en la tabla \ref{tab:estadosAdquisicion}.  Asimismo, se indican las señales válidas que puede recibir la MEF junto con las transiciones que éstas provocan.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[htpb]
\centering
\caption[Descripción de los estados de la MEF principal del módulo de adquisición.]{Descripción de los estados de la MEF principal del módulo de adquisición.  Se indican las señales que puede recibir junto con las acciones más relevantes de cada estado.}
\label{tab:estadosAdquisicion}
\resizebox{\textwidth}{!}{%
\begin{tabular}{lll}
\toprule
\multicolumn{1}{c}{\textbf{Estado}} & \multicolumn{1}{c}{\textbf{Señal para cambio}} & \multicolumn{1}{c}{\textbf{Acciones y actividades}} \\ \midrule
DISABLE & Reset o sig\_disable & \begin{tabular}[c]{@{}l@{}}Desinicializar el TIMER0.\\ Deshabilitar la interrupción TIMER0\_IRQn. \\ Desinicializar el GPIO 3[0].\\ Cambiar el estado del módulo de READY a DISABLE.\end{tabular} \\
 &  &  \\
INIT & sig\_init & \begin{tabular}[c]{@{}l@{}}Inicializar el TIMER0.\\ Habilitar la interrupción TIMER0\_IRQn.\\ Inicializar el GPIO3[0].\\ Cambiar el estado del módulo de DISABLE a READY.\end{tabular} \\
 &  &  \\
IDLE & transición incondicional & Cambiar estado del módulo de PROCESSING a READY. \\
 &  &  \\
CONFIG & sig\_config & Realizar cambios de configuración al módulo. \\
 &  &  \\
CHECK & sig\_check & Realizar autochequeo e informar al módulo de control \\
 &  &  \\
ADQUIRE & sig\_timeout & Ejecutar tarea periódica de adquisición de datos \\ \bottomrule
\end{tabular}%
}
\end{table}
%\subsection{Sensor de velocidad de viento}
%\label{subsec:anemometro}

\section{Módulo interfaz máquina-hombre}
\label{sec:HMI}

El propósito del módulo interfaz máquina-hombre (HMI, por sus siglas en inglés) es proveer al sistema de un medio de interacción con un operador humano. Las posibles interacciones se realizan a través de una interfaz de comandos interactiva y contempla operaciones de configuración y cambio de parámetros sobre los módulos y operaciones de mantenimiento y depuración del sistema.  

La interfaz se implementa desde el microcontrolador sobre un puerto serie de tipo \textit{Universal Asynchronous Receiver-Transmitter} o UART a través de un conversor RS232/USB de la firma FTDI incorporado en la CIAA-NXP, hasta llegar finalmente a la PC del operador humano.

El código del módulo incluye directivas de compilación condicional que permiten cambiar la cantidad y el nivel de detalle de los mensajes que el sistema envía a través de la interfaz.  Esta opción debe definirse en tiempo de compilación y no puede ser modificada en tiempo de ejecución, es decir, una vez que el sistema esté en funcionamiento  

Mediante la definición de una MACRO en el archivo \texttt{board\_api.h}:
\begin{verbatim}
  #define DEBUG_ENABLE
\end{verbatim}

\noindent se habilitan funciones de depuración que envían mensajes a través de la UART como puede verse en el algorirmo \ref{lst:debug}.  

Adicionalmente, si se define la MACRO \texttt{DEBUG\_SEMIHOSTING} se pueden utilizar los recursos de entrada/salida de la PC host que esté depurando el sistema embebido. 

Si la MACRO \texttt{DEBUG\_ENABLE} no es definida, las funciones no se incluyen en el código, ahorrando recursos al sistema.

\vspace{10px}

\begin{lstlisting}[caption={Macros para habilitar/deshabilitar mensajes de depuración del código.},label={lst:debug}]
#if defined(DEBUG_ENABLE)

  #if defined(DEBUG_SEMIHOSTING)
	  
    #define DEBUGINIT()
    #define DEBUGOUT(...) printf(__VA_ARGS__)
    #define DEBUGSTR(str) printf(str)
    #define DEBUGIN() (int) EOF

  #else
  
    #define DEBUGINIT() Board_Debug_Init()
    #define DEBUGOUT(...) printf(__VA_ARGS__)
    #define DEBUGSTR(str) Board_UARTPutSTR(str)
    #define DEBUGIN() Board_UARTGetChar()
  
  #endif /* defined(DEBUG_SEMIHOSTING) */

#else
  
  #define DEBUGINIT()
  #define DEBUGOUT(...)
  #define DEBUGSTR(str)
  #define DEBUGIN() (int) EOF
  
#endif /* defined(DEBUG_ENABLE) */
\end{lstlisting}

Para acceder a la interfaz se debe utilizar una terminal serie tipo \texttt{screen} \citep{screen} en configuración 8N1 a 115200 baudios. 

Existen emuladores de terminales serie como \textit{cutecom}, de gran difusión, que presentan el inconveniente de no implementar funciones de control definidas en los estándares ANSI X3.64 (ISO 6429) e ISO 2022 por lo que la visualización de la interfaz en estas consolas puede ser defectuosa y no se recomienda su uso.


\subsection{Interfaz}
\label{subsec:interfaz}

El propósito de la interfaz desarrollada es servir como prueba de concepto e incluye un mínimo de funcionalidad para cumplir los requerimientos relacionados a la controlabilidad de la estación, principalmente en lo referido al período de muestreo de los sensores del módulo de adquisición. 

Cabe destacar que el valor de esta interfaz no está en su estética ni en su facilidad de uso, sino en la arquitectura subyacente que permite obtener información sistema y operar sobre sus distintos componentes.

Una primera versión de la interfaz operativa se presenta en la figura \ref{fig:interfaz_main}, donde pueden apreciarse 4 zonas funcionales identificadas con recuadros de color rojo, a saber: encabezado, menú de opciones, línea de comandos y barra de estado. 

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/interfaz_detalles.pdf}
	\caption[]{Vista de la pantalla principal de la interfaz. Se destacan con recuadros rojos 4 secciones dentro de la pantalla: encabezado, menú de opciones, línea de comandos y barra de estado.}
	\label{fig:interfaz_main}
\end{figure}

En el encabezado puede observarse el nombre de la estación EAMMRA, por las siglas de ``Estación Autónoma Marítima de Medición de Ruido Ambiente'' junto en una identificación del número de revisión de la interfaz, en el caso de la figura \ref{fig:interfaz_main}, r1.0. 

En la zona asociada al menú de opciones se presentan los comandos que puede introducir el operador. En cada pantalla, las opciones que se muestran cambian según el contexto.

Se realiza un eco de los comandos ingresados, que aparecen en la línea de comandos para confirmación del usuario. Asimismo, si se ingresa un caracter que no sea parte de las opciones disponibles, el sistema lo informa a continuación del eco con el mensaje `` no es un comando valido.'' 

Los diferentes módulos pueden enviar mensajes para el usuario que aparecerán en la sección indicada como barra de estado.  De igual manera, cuando el sistema requiera confirmación por parte del usuario, se exhibirá un mensaje para tal fin en esta sección.

Desde el menú principal se puede acceder al modo configuración para interactuar directamente con los módulos del sistema.  Se presenta la pantalla principal de este modo en la figura \ref{fig:interfaz_config}.  Para acceder a las opciones de un módulo en particular se debe ingresar el número asociado a éste en el menú de opciones.  A excepción de la pantalla principal, todas las pantallas cuentan con una opción (X) para volver al menú anterior.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/interfaz_config.png}
	\caption[]{Vista de la pantalla principal del modo configuración de la interfaz máquina-hombre.}
	\label{fig:interfaz_config}
\end{figure}

Sin pérdida de generalidad, ya que todos los módulos comparten las mismas opciones, se presenta en la figura \ref{fig:interfaz_config_detalle} una vista de detalle de la pantalla de configuración del módulo de adquisición, también llamado módulo 1-WIRE por el tipo de sensor que controla. Se puede observar la opción de configuración elegida en la línea de comandos y el pedido de confirmación en la barra de estado.

Se contempla diferenciar a futuro las opciones de cada módulo acorde se agregue funcionalidad a los mismos. Las opciones actualmente disponibles son las siguientes:

\begin{itemize}
  \item \texttt{(D)} Habilitar / Deshabilitar: permite intercambiar el estado del módulo entre \texttt{READY} y \texttt{DISABLED}.  Para tal fin, si el módulo se encuentra en estado \texttt{READY}, se le envía una señal sig\_disable.  En caso que se encuentre en estado \texttt{DISABLED} se le envía una señal sig\_init.  Antes de enviar la señal correspondiente se informa al usuario el estado actual del módulo y se pide que confirme o cancele la operación mediante el ingreso de \texttt{`s'} o \texttt{`n'}, respectivamente.
  \item \texttt{(I)} Info del modulo: muestra el estado actual del módulo en la barra de estado.  Las respuestas posibles son \texttt{READY}, \texttt{PROCESSING} y \texttt{DISABLED}
  \item \texttt{(C)} Configurar: permite cambiar la configuración del módulo.  En esta etapa del desarrollo se implementó únicamente la posibilidad de cambiar el tiempo con que se ejecuta la tarea periódica, si la hubiera.
  \item \texttt{(A)} Autocomprobación: permite realizar una comprobación interna de funcionamiento mediante el envío de una señal sig\_check al módulo. En esta etapa del desarrollo la funcionalidad está implementada con una función \textit{mock} que devuelve un mensaje en la barra de estado. 
  \item \texttt{(X)} para volver al menú anterior: cambia el menú a la pantalla principal del modo configuración.
\end{itemize}

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/interfaz_config_detalle.png}
	\caption[Pantalla de configuración del módulo de adquisición.]{Pantalla de configuración del módulo de adquisición con una operación de deshabilitación en curso.} 
	\label{fig:interfaz_config_detalle}
\end{figure}

Asimismo, desde el menú principal se puede acceder a un modo \textit{debug} con opciones de depuración y mantenimiento como puede observarse en la figura \ref{fig:interfaz_debug}.  

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/interfaz_debug.png}
	\caption{Vista de la pantalla principal del modo debug de la interfaz máquina-hombre.}
	\label{fig:interfaz_debug}
\end{figure}

Las opciones para este modo son:

\begin{itemize}
  \item \texttt{(E)} Estado de modulos: muestra el estado actual de todos los módulo del sistema en la barra de estado.
  \item \texttt{(A)} Comprobación: permite realizar una comprobación interna de funcionamiento a todos los módulos. En esta etapa del desarrollo la funcionalidad está implementada con una función \textit{mock} que devuelve un mensaje en la barra de estado y registra los resultados en el log del sistema.
  \item \texttt{(L)} Ver log del sistema: permite realizar un \textit{dump} del log del sistema en la consola.  Esto significa que se imprime en la terminal serie todo el contenido del archivo de log ubicado en la tarjeta de memoria microSD. Presionando cualquier tecla se limpia la pantalla y se vuelve al menú principal del modo \textit{debug}.
  \item \texttt{(X)} para volver al menú anterior: cambia el menú a la plantalla principal del modo \textit{debug}.
\end{itemize}

En la tabla \ref{tab:interfaz_config}, se recopilan los comandos que se pueden ingresar por la interfaz en el modo configuración junto con una descripción de la funcionalidad que activa en el sistema.  Asimismo, se explicita si la función se encuentran implementada o maquetada. 

\begin{table}[htpb]
\centering
\caption{Opciones disponibles en el modo configuración de la interfaz.  Se indica el comando para seleccionar la opción y si ésta se encuentra implementada o maquetada.}
\label{tab:interfaz_config}
%\resizebox{\textwidth}{!}{%
\begin{tabular}{ccccc}
\toprule
\textbf{\textbf{Opción}} & \textbf{Descripción} & \textbf{Implementada} & \textbf{Maquetada} \\ \midrule
D & \begin{tabular}[c]{@{}c@{}}Habilitar / Deshabilitar el módulo.\\ Se informa el estado actual\\ Se pide confirmación del usuario\end{tabular} & X &  \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
I & Informa el estado del módulo. & X &  \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
C & \begin{tabular}[c]{@{}c@{}}Configurar el módulo\\ Permite cambiar el valor de\\ period dentro de la estructura\\ de control del módulo\end{tabular} & X &  \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
A & \begin{tabular}[c]{@{}c@{}}Autocomprobación del módulo.\\ Informa en la barra de estado\\ el resultado de la verificación.\end{tabular} &  & X \\ \bottomrule
\end{tabular}%
%}
\end{table}

En forma análoga, se presenta en la tabla \ref{tab:interfaz_debug}, una recopilación de los comandos que se pueden ingresar en el modo debug junto con una descripción de la misma.  Asimismo, se explicita si la función se encuentran implementada o maquetada. 

\begin{table}[htpb]
\centering
\caption{Opciones disponibles en el modo debug de la interfaz.  Se indica el comando para seleccionar la opción y si ésta se encuentra implementada o maquetada.}
\label{tab:interfaz_debug}
%\resizebox{\textwidth}{!}{%
\begin{tabular}{cccc}
\toprule
\textbf{Opción} & \textbf{Descripción} & \textbf{Implementada} & \textbf{Maquetada} \\ \midrule
E & \begin{tabular}[c]{@{}c@{}}Informa el estado actual\\ de todos los módulos \\ en la barra de estado\end{tabular} & X &  \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
A & \begin{tabular}[c]{@{}c@{}}Autocomprobación\\ de todos los módulos.\\ Se registra el resultado\\ en el log del sistema\end{tabular} &  & X \\
\multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
L & \begin{tabular}[c]{@{}c@{}}Listar el contenido del \\ log del sistema.\\ Se limpia presionando\\ cualquier tecla\end{tabular} & X & \\
\bottomrule 
\end{tabular}
%}
\end{table}

En los módulos que tiene funciones maquetadas se reemplazó la llamada a la función que debería realizar la implementación por el envío de un mensaje generado en el propio módulo hacia la interfaz HMI.  De esta manera se puede comprobar el correcto funcionamiento de la interfaz y el circuito de  comunicación entre módulos, es decir, que:

\begin{itemize}
	\item el comando es correctamente recibido por la interfaz,
	\item la interfaz envía correctamente una señal al módulo correspondiente,
	\item el módulo correspondiente recibe la señal y contesta con un mensaje que se visualiza en la barra de estado de la interfaz.
\end{itemize}

Se contempla incluir en versiones futuras, además de cambios estilísticos, la implementación completa de funcionalidades que en la presente versión se encuentran maquetadas.  Si bien estás y otras características son deseable para la usabilidad de la interfaz y la operación de la estación, no formaban parte de los requerimientos enumerados en la sección \ref{sec:requerimientos}. 



\subsection{Máquina de estados finitos}

El diagrama de estado de la MEF principal del módulo puede apreciarse en la figura \ref{fig:mef_HMI}, donde se observa el punto de entrada con un circulo negro, los estados que puede tomar la máquina y las señales que provocan los cambios de estado. Se omiten del gráfico las salidas del sistema por simplicidad. 

Igualmente, debe notarse que cuando el sistema es energizado o luego de un \textit{reset}, el módulo se encuentra deshabilitado, con la MEF en el estado \texttt{DISABLE}, del cual sólo puede salir si se recibe una señal de inicialización.  

Una vez inicializado, el módulo se encontrará la mayor parte del tiempo en el estado \texttt{IDLE} a la espera de un comando válido para procesar.  

Cuando el módulo esté realizando alguna operación de procesamiento de comandos recibidos por el usuario, configuración o autochequeo, el estado en la del módulo tendrá el valor \texttt{PROCESSING} para indicarle al módulo de control que debe tener acceso a tiempo de CPU para poder completar las operaciones pendientes.  

Todas las operación del módulo desde que es inicializado terminan incondicionalmente en el estado \texttt{IDLE}, en donde el valor de la variable que registra el estado cambia de \texttt{PROCESSING} a \texttt{READY}.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=\textwidth]{./Figures/MEF_HMI_2.pdf}
	\caption[MEF principal del módulo de HMI]{Máquina de estados finitos principal del módulo de interfaz máquina-hombre}
	\label{fig:mef_HMI}
\end{figure}

Se describen las principales acciones y actividades de cada estado en la tabla \ref{tab:estadosHMI}.  Asimismo, se indican las señales válidas que puede recibir la MEF junto con las transiciones que éstas provocan.


% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[htpb]
\centering
\caption[Descripción de los estados de la MEF principal del módulo HMI.]{Descripción de los estados de la MEF principal del módulo de interfaz máquina-hombre (HMI).  Se indican las señales que puede recibir junto con las acciones más relevantes de cada estado.}
\label{tab:estadosHMI}
\resizebox{\textwidth}{!}{%
\begin{tabular}{lll}
\toprule
\multicolumn{1}{c}{\textbf{Estado}} & \multicolumn{1}{c}{\textbf{Señal para cambio}} & \multicolumn{1}{c}{\textbf{Acciones y actividades}} \\ \midrule
DISABLE & Reset o sig\_disable & \begin{tabular}[c]{@{}l@{}}Desinicializar la UART.\\ Deshabilitar la interrupción de la UART. \\ Deshabilitar la transmisión de la UART\\ Cambiar el estado del módulo de READY a DISABLE.\end{tabular} \\
 &  &  \\
INIT & sig\_init & \begin{tabular}[c]{@{}l@{}}Inicializar la UART.\\ Habilitar la interrupción de la UART.\\ Habilitar la transmisión de la UART.\\ Cambiar el estado del módulo de DISABLE a READY.\end{tabular} \\
 &  &  \\
IDLE & transición incondicional & Cambiar estado del módulo de PROCESSING a READY. \\
 &  &  \\
CONFIG & sig\_config & Realizar cambios de configuración al módulo. \\
 &  &  \\
CHECK & sig\_check & Realizar autochequeo e informar al módulo de control \\
 &  &  \\
PROCESS & sig\_process & Procesar los comandos recibidos \\ 
 &  &  \\
STATUS & sig\_status & Enviar información de un módulo al usuario \\ \bottomrule
\end{tabular}%
}
\end{table}

\clearpage

\section{Módulo de control}
\label{sec:control}
